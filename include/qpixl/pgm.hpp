// (C) Copyright Daan Camps, Mercy Amankwah, E. Wes Bethel, Talita Perciano and
//               Roel Van Beeumen

#ifndef qpixl_pgm_hpp
#define qpixl_pgm_hpp

#include <fstream> 
#include <sstream>
#include "qpixl/util.hpp"

/// QPIXL namespace
namespace qpixl {

  /**
   *  \brief Read portable grayscale map (PGM) in ASCII format from file 
   *        `fileName` to vector `data`. The number of rows `nrows`, number of
   *        columns `ncols` and maximum pixel value `maxval` are stored. The 
   *        flag `zeroPad` determines how the data is padded to the next power 
   *        of 2.
   *
   *        - `zeroPad` = 0 : no zero padding (default)
   *        - `zeroPad` = 1 : the image is embedded in a 2^n x 2^m image
   *        - `zeroPad` = 2 : the vector is zero padded to the next power of 2
   */
  template <typename V >
  int readPGMA( const std::string fileName, V& data , size_t& nrows, 
                size_t& ncols, size_t& maxval, const int zeroPad = 0 ) {
   
    using T = typename V::value_type ; 
    std::ifstream istrm( fileName , std::ios::in ) ;
    if ( !istrm.is_open( ) ) {
      std::cerr << "ERROR -- failed to open " << fileName << '\n';
      return -1 ;
    } else {
        std::stringstream ss, ss2 ;
        std::string inputLine = "" ;

        // Read first line : version
        getline( istrm, inputLine ) ;
        if (inputLine.compare("P2") != 0) {
          std::cerr << "ERROR -- Version : " << inputLine << std::endl;
          return -2 ;
        }

        // Check if next line is a comment and check if so
        getline( istrm, inputLine );
        if (inputLine[0] == '#') getline( istrm, inputLine ) ;
        ss2 << inputLine ;
        ss2 >> ncols >> nrows ;

        // Continue with a string-stream for remainder of header and data
        ss << istrm.rdbuf( ) ;

        // Read maximum pixel value
        ss >> maxval ;        

        // Read data
        size_t ldm = 0 ;
        if ( zeroPad == 0 ) {
          data.resize( nrows * ncols , 0 ) ;
          ldm = nrows ;
        } else if ( zeroPad == 1 ) {
          int pow2nrows = qpixl::nextpow2( nrows ) ;
          int pow2ncols = qpixl::nextpow2( ncols ) ;
          data.resize( pow2nrows * pow2ncols , 0 ) ;
          ldm = pow2nrows ;
        } else if ( zeroPad == 2 ) {
          int pow2tot = qpixl::nextpow2( nrows * ncols ) ;
          data.resize( pow2tot , 0 ) ;  
          ldm = nrows ;
        } else {
          std::cerr << "ERROR -- zeroPad : " << zeroPad << std::endl ;
          return -3 ;
        }

        for ( int row = 0; row < nrows; ++row ) {
          for ( int col = 0; col < ncols; ++col ) {
            ss >> data[row + col * ldm];    
          }
        }
      
        // Close file
        istrm.close();

        return 0 ;

    }
  }

  /**
   *  \brief Write grayscale vector `data` to a portable grayscale map (PGM) 
   *        file in ASCII format. The number of rows `nrows`, number of columns
   *        `ncols`, maximum pixel value `maxval`, and type of `zeroPad 
   *        (0, 1, or 2) [see readPGMA] are required for correct formatting.
   */
  template <typename V>
  int writePGMA( const std::string fileName, V& data , const size_t nrows , 
                 const size_t ncols , const size_t maxval , 
                 const int zeroPad = 0 ) {
    using T = typename V::value_type ; 
    std::ofstream ostrm( fileName , std::ios::out ) ;

    if ( !ostrm.is_open( ) ) {
      std::cerr << "ERROR -- failed to open " << fileName << std::endl ;
      return -1 ;
    } else {

      // Write header
      ostrm << "P2" << std::endl ;
      ostrm << "# Generated by QPIXL++" << std::endl ;
      ostrm << ncols << " " << nrows << std::endl ;
      ostrm << maxval << std::endl ;

      // Write data
      size_t ldm = 0 ;
      if ( zeroPad == 0 || zeroPad == 2 ) {
        ldm = nrows ;
      } else if ( zeroPad == 1 ) ldm = qpixl::nextpow2( nrows ) ;
      else {
        std::cerr << "ERROR -- zeroPad : " << zeroPad << std::endl ;
          return -3 ;
      }

      for ( int row = 0; row < nrows; ++row ) {
          for ( int col = 0; col < ncols; ++col ) {
            ostrm << std::min( std::max( 
                     int( ceil( data[row + col * ldm] ) ), 0 ), int(maxval) ) 
                  << " " ;    
          }
          ostrm << std::endl ;
      }
    }

    // Close file
    ostrm.close() ;

    return 0 ;
  }
} // namespace qpixl

#endif